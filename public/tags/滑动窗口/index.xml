<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>滑动窗口 on Jeffrey&#39;s Blog</title>
    <link>/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</link>
    <description>Recent content in 滑动窗口 on Jeffrey&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright>
    <lastBuildDate>Fri, 19 Jun 2020 16:18:47 +0800</lastBuildDate>
    
	<atom:link href="/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>leetcode 209. 长度最小的子数组</title>
      <link>/2020/06/leetcode209/</link>
      <pubDate>Fri, 19 Jun 2020 16:18:47 +0800</pubDate>
      
      <guid>/2020/06/leetcode209/</guid>
      <description>问题描述 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。
示例：
输入：s = 7, nums = [2,3,1,2,4,3] 输出：2 解释：子数组 [4,3] 是该条件下的长度最小的连续子数组。
问题分析 使用滑动窗口的思想，双指针
Solution 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  public int minSubArrayLen(int s, int[] nums) { if(nums.length &amp;lt; 1){ return 0; } int minlength = Integer.MAX_VALUE; int left = 0; int right = 0; int sum = 0; while(right &amp;lt; nums.</description>
    </item>
    
  </channel>
</rss>